#!/usr/bin/env python
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
import xml.etree.ElementTree as ET
import os.path

#fwhost can be either an IP address or a DNS record - enter it below between the quotation marks
#for an IP address, it would look like: fwhost = "192.168.1.1"
#for a DNS object, it would look like: fwhost = "fwmanagement.yourdomain.com"
fwhost = ""

#fwkey is the API key that is generated by the firewall for the account that the API will impersonate
#You can generate the key using the following URL to the firewall:
#https://<firewall>/api?type=keygen&user=<username>&password=<password>
#The response will be in XML and the key will be between the <key> and </key> tags
#Copy that entire key into the variable below between the quotation marks
fwkey = ""

def lastPcapID():
	#Check to see if there is a file containing the last logid that we polled:
	if (os.path.isfile("lastpcap.txt")):
		#Open and read the file
		file = open("lastpcap.txt", "r")
		lastpcap = file.read()
		file.close()
	else:
		lastpcap = 0
	return lastpcap

def getPcapLogs(fwhost, fwkey):
	#pull log entries with PCAPs - need pcapid, serial number, and generated time from the log

	jobvalues = {'type': 'log', 'log-type': 'threat', 'query': '(flags has pcap)', 'key': fwkey}
	jobcall = 'https://%s/api/' % (fwhost)
	jobrequest = requests.post(jobcall, data=jobvalues, verify=False)

	#find the jobid of the query
	jobtree = ET.fromstring(jobrequest.text)
	jobid = jobtree.find('result').find('job').text

	#Query the job until status is FIN
	jobstatus = 0
	while (jobstatus <> "FIN"):
		#Get the status of the query job
		querycommand = '<show><query><result><id>%s</id></result></query></show>' % (jobid)
		queryvalues = {'type': 'op', 'cmd': querycommand, 'key': fwkey}
		querycall = 'https://%s/api/' % (fwhost)
		queryrequest = requests.post(querycall, data=queryvalues, verify=False)
		querytree = ET.fromstring(queryrequest.text)
		jobstatus = querytree.find('result').find('job').find('status').text

	#Pull the log data from the XML
	logs = querytree.find('result').find('log').find('logs').findall('entry')

	#Unfortunately, the logs are returned in most-recent-log-first order, which is the opposite of what we need.
	#The following chunk of code puts the log information that we need into an array and flips the order so we
	#can process from oldest to newest.
	logarray = []
	for log in logs:
		serial = log.find('serial').text
		pcapid = log.find('pcap_id').text
		time = log.find('time_generated').text
		logarray.append((pcapid, serial, time))
	logarray.sort()

	return logarray

def getPcap(fwhost, fwkey, pcapid, serial, time):
	#Pull the pcap from the firewall
	values = {'type': 'export', 'category': 'threat-pcap', 'serialno': serial, 'pcapid': pcapid, 'search-time': time, 'key': fwkey}
	logcall = 'https://' + fwhost + '/api'
	logrequest = requests.post(logcall, data=values, verify=False, stream=True)

	#Generate a unique filename based on pcapid, open the file, write the raw pcap data received from the firewall, and close the file.
	filename = pcapid + '.pcap'
	file = open(filename, "wb")
	file.write(logrequest.raw.read())
	file.close()

	#Update the pcapid counter so we do not re-process the same logs.
	file = open("lastpcap.txt", "w")
	file.write(pcapid)
	file.close()

#This is the main function of the program where all of the functions written above get called
lastpcap = lastPcapID()
logarray = getPcapLogs(fwhost, fwkey)
for log in logarray:
	pcapid = log[0]
	serial = log[1]
	time = log[2]
	if (pcapid > lastpcap):
		getPcap(fwhost, fwkey, pcapid, serial, time)
